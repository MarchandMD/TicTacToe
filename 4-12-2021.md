CURRENT GOAL: define and test `#draw?` and `#winner?`  
stretch goal: clean up 4-11-2021.md and prep for being an article

# `#draw?`

So, the logic of a draw situation in TicTacToe is pretty easy to describe: There are no empty spaces and no three-in a row across, diagonally or down. 

so the idea of "three-in-a-row" is what's considered a winner.  

the idea of a winner is going to be coded for next, so I don't really need to fuss over the idea of "is there a winner on a full board?". All I really need to do is mash all the rows of the `board` into a single array, and then look at the results with a call to `#none_empty?`. And if `#none_empty?` returns `true`, then I know that the game is a draw. 

I hope that logic makes sense.  

So here's the code for testing for a draw (of course, this would happen after the `board` has been reviewed for a winner): 

```ruby
def draw?
  grid.flatten.map { |cell| cell.value }.none_empty? 
end
```

Couple of things to say about this method: 

1. Remember, this is back to being an instance method for the `Board` class. So it will have access to the instance variable `@grid`. 
2. The `@grid` will be composed of `Cell` objects, which will respond to the `#value` method (remember, `#value` is an instance method of the `Cell` class. `Cell#value` and can be seen in `/cell.rb`)
3. `#flatten` and `#map` are built in methods already; check the documentation for how to use them
4. this is using `#none_empty?` which is a monkey patched method, specific only to my program here and extending Ruby for my purposes  

It's entirely possible that there is some naming issues; For example, if this Gem was a real Gem and was used with a different Gem that also extended the Ruby language using a similar method name. But that's unlikely. And if I ran into that situation, I'd probably be a much better programmer at that time. So not a big deal. 

Ok, current goal was not met. So can come back to this one and pick up here. Stretch goal is a good one, because it's scope should be refined. 

CURRENT GOAL: SAME AS ABOVE  
*stretch goal: same as above*

## THERE ARE SO MANY THINGS THAT COULD BECOME THEIR OWN STAND ALONE LITTLE LESSONS! 

Now that `#draw?` is defined....should I test it? Well not yet. testing a situation where a game ends in a draw will require a lot more of "pseudo-code" in the test...and I don't really know how to do that efficiently. The tutorial will teach me how to do that. 

So the next thing to do is: 

# `#winner?`

So, before I attempt to tackle the `#winner?` method, I need to verbalize how to look at a tic tac toe board and determine if there's a winner. Which I've sort of already done...

> a player win's tic tac toe when they get three in a row, horizontally, vertically or diagonally

Ok, then how do I do that when looking at the `board` object? 

Well, imagining a ticTacToe board with like, 3 Xs across the top is the most obvious thing. So then the idea is that the first `Array` returns `true` when `#all_same?` is called upon it. And `#all_same?` is a method I wrote to extend the `Array` class of Ruby. So that's easy to understand. 

Next would be 3-in-a-row vertically. 

How the heck would I determine if that were true? 

This is where things get a little confusing. But I'll break it down. 

So, this is how the program is going to determine if there's a winner:

1. look at all the rows of board (remember, the `Board` object is just three arrays inside another array)
2. Do something called `#transpose` to the board, which will essentially just swap the places of the rows and the columns. It's actually kinda neat, and I'd recommend checking out the Ruby documentation if you don't know what that is, or are curious. 
3. Look at the diagonals, by coding them the long way

all those different things (the rows, the transposed columns, and the diagonals) will all be arrays. All those arrays will be put in one big Array, and then each of those possible WINNING POSITIONS will be evaluated (as arrays, one at a time). 


